C51 COMPILER V9.55   PLL_CONTROLINTERFACE                                                  06/15/2018 23:22:22 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE PLL_CONTROLINTERFACE
OBJECT MODULE PLACED IN .\Objects\PLL_ControlInterface.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE RFFC\PLL_ControlInterface.c OPTIMIZE(9,SPEED) BROWSE INCDIR(.\driver;.\F
                    -33x;.\RFFC) DEBUG OBJECTEXTEND PRINT(.\Listings\PLL_ControlInterface.lst) TABS(2) OBJECT(.\Objects\PLL_ControlInterface.
                    -obj)

line level    source

   1          #include "RFFC2071.h"
   2          #define  MAX_FRE (270000)     //2.7G
   3          #define  MIN_FRE (8500)       //85M
   4          
   5          /*
   6          U8 set_pll_reg(U32 freq)
   7          {
   8            U8  div = 0;
   9            U16 int_value   = 0;
  10            U32 frac_value  = 0;  
  11            U32 undiv_freq  = 0;
  12            
  13            div = get_vco_divider(freq);
  14            if(div ==0)
  15            {
  16              return 0;
  17            }
  18            else
  19            {
  20              //RFOUT = [INT + (FRAC/MOD)] * [fPFD]/RF divider
  21              undiv_freq  = div * freq;
  22              int_value   = (U16)(undiv_freq/REF_F);
  23              frac_value  = undiv_freq%REF_F;
  24              frac_value  = (frac_value/10000+5)/10; //Integer-valued
  25              set_pll(div,int_value,frac_value);  
  26            }
  27            return 1;
  28          }
  29          void RFFC2071_test(S_RFFC2071_REG * rffc2071_reg_t)
  30          {
  31            U8 i=31;
  32            U16 DATA;
  33            U16 * str = (U16 *)rffc2071_reg_t;
  34              
  35            for(i=0;i<=RFFC2071_MAP_DEV_CTRL;i++)
  36            {
  37              DATA = * str;
  38              
  39              RFFC2071_write(i, DATA );
  40              
  41              str += 1;
  42            }
  43          }
  44          void RFFC2071_setup(void)
  45          {
  46            S8 * ret;
  47            
  48            U32 buffer,fre;
  49            U32 NoFre[4]={0,0,0,0};
  50            U16 NoWid[4]={0,0,0,0};
  51            U8 enabl=0,i,MAXf=0,MINf=0;
  52            
  53            if(!CENTER_FREQ_FLAG)   return;
C51 COMPILER V9.55   PLL_CONTROLINTERFACE                                                  06/15/2018 23:22:22 PAGE 2   

  54            if(vSystem_Sw_s.IS_ON == OFF)  return;
  55            
  56          
  57          
  58            //取第一子带中心频点
  59            ret = DataBuf + RAM_NO1_FREQ;
  60            for(i=0;i<4;i++)
  61            {
  62              buffer = (U32)*ret;
  63              buffer &= (U32)0x000000ff;    
  64              
  65              NoFre[0] |= (buffer << (8*i));
  66              ret++;
  67            }
  68            //取第一子带带宽
  69            ret = DataBuf + RAM_NO1_BANDWIDTH;
  70            for(i=0;i<2;i++)
  71            {
  72              buffer = (U32)*ret;
  73              buffer &= (U32)0x000000ff;    
  74              
  75              NoWid[0] |= (buffer << (8*i));
  76              ret++;
  77            }
  78            //取第2子带中心频点
  79            ret = DataBuf + RAM_NO2_FREQ;
  80            for(i=0;i<4;i++)
  81            {
  82              buffer = (U32)*ret;
  83              buffer &= (U32)0x000000ff;    
  84              
  85              NoFre[1] |= (buffer << (8*i));
  86              ret++;
  87            }
  88            //取第2子带带宽
  89            ret = DataBuf + RAM_NO2_BANDWIDTH;
  90            for(i=0;i<2;i++)
  91            {
  92              buffer = (U32)*ret;
  93              buffer &= (U32)0x000000ff;    
  94              
  95              NoWid[1] |= (buffer << (8*i));
  96              ret++;
  97            }
  98            //取第3子带中心频点
  99            ret = DataBuf + RAM_NO3_FREQ;
 100            for(i=0;i<4;i++)
 101            {
 102              buffer = (U32)*ret;
 103              buffer &= (U32)0x000000ff;    
 104              
 105              NoFre[2] |= (buffer << (8*i));
 106              ret++;
 107            }
 108            //取第3子带带宽
 109            ret = DataBuf + RAM_NO3_BANDWIDTH;
 110            for(i=0;i<2;i++)
 111            {
 112              buffer = (U32)*ret;
 113              buffer &= (U32)0x000000ff;    
 114              
 115              NoWid[2] |= (buffer << (8*i));
C51 COMPILER V9.55   PLL_CONTROLINTERFACE                                                  06/15/2018 23:22:22 PAGE 3   

 116              ret++;
 117            }
 118            //取第4子带中心频点
 119            ret = DataBuf + RAM_NO4_FREQ;
 120            for(i=0;i<4;i++)
 121            {
 122              buffer = (U32)*ret;
 123              buffer &= (U32)0x000000ff;    
 124              
 125              NoFre[3] |= (buffer << (8*i));
 126              ret++;
 127            }
 128            //取第4子带带宽
 129            ret = DataBuf + RAM_NO4_BANDWIDTH;
 130            for(i=0;i<2;i++)
 131            {
 132              buffer = (U32)*ret;
 133              buffer &= (U32)0x000000ff;    
 134              
 135              NoWid[3] |= (buffer << (8*i));
 136              ret++;
 137            }
 138            //使能子带
 139            if(DataBuf[RAM_NO1_OFFON])
 140            {enabl |= 1;}
 141            if(DataBuf[RAM_NO2_OFFON])
 142            {enabl |= 2;} 
 143            if(DataBuf[RAM_NO3_OFFON])
 144            {enabl |= 4;}
 145            if(DataBuf[RAM_NO4_OFFON])
 146            {enabl |= 8;}
 147            
 148            //去最大、最小中心频点 序号
 149            for(i=0;i<4;i++)
 150            {
 151              if(enabl & (0x01<<i))
 152              {
 153                MAXf = i;MINf = i;
 154                break;
 155              }
 156            }
 157            for(i=MAXf;i<4;i++)
 158            {
 159              if(!(enabl & (0x01<<i)))
 160              {continue;}
 161              
 162              if(NoFre[MAXf] < NoFre[i])
 163              {MAXf = i;}
 164              
 165              if(NoFre[MINf] > NoFre[i])
 166              {MINf = i;}
 167            }
 168            
 169            //得到下行中心频点
 170            fre = (NoFre[MINf] - (NoWid[MINf] / 2) + NoFre[MAXf] + (NoWid[MAXf] / 2))/2 ;
 171            ret = DataBuf + RAM_TX_CENTER_FREQ;
 172            for(i=0;i<4;i++)
 173            {
 174              *ret = (S8) (fre >> (8*i));
 175              ret++;
 176            }
 177            fre += 9216 ; //10kHz
C51 COMPILER V9.55   PLL_CONTROLINTERFACE                                                  06/15/2018 23:22:22 PAGE 4   

 178            RFFC2071_set(fre) ; 
 179            
 180            //得到上行中心频点
 181            fre -= 9216 ; //10kHz
 182            fre -= 9500 ; //10kHz
 183            ret = DataBuf + RAM_RX_CENTER_FREQ;
 184            for(i=0;i<4;i++)
 185            {
 186              *ret = (S8) (fre >> (8*i));
 187              ret++;
 188            }
 189            fre -= 9216 ; //10kHz 
 190            RFFC2071_set(fre) ;
 191            
 192            CENTER_FREQ_FLAG = 0;   //clear flag
 193          
 194          }
 195          */
 196          
 197          // the unit of freq: 10Khz
 198          
 199          U8 pll_set(U32 fre)
 200          {
 201   1        S_RFFC2071_REG idata str;
 202   1      
 203   1        if((fre > MAX_FRE)||(fre < MIN_FRE))
 204   1        {
 205   2          return 0;
 206   2        }
 207   1        else
 208   1        {
 209   2      
 210   2          RFFC2071_reset_device(&str);
 211   2          
 212   2          RFFC2071_REG_INIT(&str);
 213   2          
 214   2          RFFC2071_PD_INIT(&str); 
 215   2      
 216   2          RFFC2071_N_INIT(fre,&str);  //10kHz 
 217   2          
 218   2          RFFC2071_setup_device(&str);          //1
 219   2          RFFC2071_set_calibration(&str);       //2
 220   2          RFFC2071_set_oper_freq(&str);         //3
 221   2          RFFC2071_set_calibration_mode(&str);  //4
 222   2          RFFC2071_enable_device(&str);         //5
 223   2          return 1;
 224   2        }
 225   1      }
 226          bit pll_get_lockstate(void)
 227          {
 228   1        return RFFC2071_lock();
 229   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    124    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----      62
   BIT SIZE         =   ----    ----
C51 COMPILER V9.55   PLL_CONTROLINTERFACE                                                  06/15/2018 23:22:22 PAGE 5   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
